#!/usr/bin/env node

/**
 * AI Security Vulnerability Scanner
 * Analyzes code for security vulnerabilities and suggests fixes
 */

const fs = require('fs');
const path = require('path');
const chalk = require('chalk');

class SecurityVulnerabilityScanner {
  constructor () {
    this.results = {
      score: 0,
      vulnerabilities: [],
      recommendations: [],
      summary: {}
    };

    this.securityPatterns = {
      critical: [
        {
          pattern: /eval\s*\(/,
          message: 'Use of eval() allows arbitrary code execution',
          cwe: 'CWE-94',
          recommendation: 'Replace eval() with safer alternatives like JSON.parse() for JSON data'
        },
        {
          pattern: /Function\s*\(/,
          message: 'Function constructor allows arbitrary code execution',
          cwe: 'CWE-94',
          recommendation: 'Avoid Function constructor, use regular function declarations'
        },
        {
          pattern: /setTimeout\s*\(\s*["'][^"']*["']/,
          message: 'setTimeout with string argument allows code execution',
          cwe: 'CWE-94',
          recommendation: 'Use function references instead of string arguments'
        }
      ],
      high: [
        {
          pattern: /innerHTML\s*=/,
          message: 'innerHTML assignment vulnerable to XSS attacks',
          cwe: 'CWE-79',
          recommendation: 'Use textContent or sanitize HTML before assignment'
        },
        {
          pattern: /document\.write\s*\(/,
          message: 'document.write() vulnerable to XSS attacks',
          cwe: 'CWE-79',
          recommendation: 'Use DOM manipulation methods instead of document.write'
        },
        {
          pattern: /outerHTML\s*=/,
          message: 'outerHTML assignment vulnerable to XSS attacks',
          cwe: 'CWE-79',
          recommendation: 'Use DOM manipulation methods or sanitize HTML'
        }
      ],
      medium: [
        {
          pattern: /Math\.random\(\)/,
          message: 'Math.random() is not cryptographically secure',
          cwe: 'CWE-338',
          recommendation: 'Use crypto.getRandomValues() for security-sensitive randomness'
        },
        {
          pattern: /atob\s*\(/,
          message: 'Base64 decoding without validation',
          cwe: 'CWE-1287',
          recommendation: 'Validate and sanitize decoded base64 content'
        },
        {
          pattern: /location\.hash\s*[^=]/,
          message: 'Direct use of location.hash without validation',
          cwe: 'CWE-80',
          recommendation: 'Validate and sanitize URL fragments before use'
        }
      ],
      low: [
        {
          pattern: /console\.log\s*\(/,
          message: 'Console logs may expose sensitive information',
          cwe: 'CWE-200',
          recommendation: 'Remove console logs or use conditional logging for production'
        },
        {
          pattern: /localStorage\.setItem/,
          message: 'localStorage stores data without encryption',
          cwe: 'CWE-922',
          recommendation: 'Use secure storage for sensitive data or encrypt before storage'
        },
        {
          pattern: /sessionStorage\.setItem/,
          message: 'sessionStorage stores data without encryption',
          cwe: 'CWE-922',
          recommendation: 'Use secure storage for sensitive data or encrypt before storage'
        }
      ]
    };
  }

  async scan (targetPath = '.') {
    console.log(chalk.blue('ðŸ”’ AI Security Vulnerability Scan Starting...'));

    try {
      const files = this.findFilesToScan(targetPath);

      for (const file of files) {
        await this.scanFile(file);
      }

      this.calculateScore();
      this.generateReport();

      console.log(chalk.green('âœ… Security Scan Complete!'));
      console.log(chalk.blue(`ðŸ›¡ï¸ Security Score: ${this.results.score}/100`));

      return this.results;
    } catch (error) {
      console.error(chalk.red('âŒ Error during security scan:'), error.message);
      throw error;
    }
  }

  findFilesToScan (targetPath) {
    const files = [];
    const extensions = ['.js', '.jsx', '.ts', '.tsx', '.html'];

    const scanDir = (dir) => {
      try {
        const items = fs.readdirSync(dir);
        for (const item of items) {
          const fullPath = path.join(dir, item);
          const stat = fs.statSync(fullPath);

          if (stat.isDirectory() && !['node_modules', '.git', 'coverage', 'dist'].includes(item)) {
            scanDir(fullPath);
          } else {
            const ext = path.extname(item);
            if (extensions.includes(ext)) {
              files.push(fullPath);
            }
          }
        }
      } catch (error) {
        // Skip directories we can't read
      }
    };

    scanDir(targetPath);
    return files;
  }

  async scanFile (filePath) {
    console.log(chalk.blue(`ðŸ” Scanning ${path.relative(process.cwd(), filePath)}...`));

    try {
      const content = fs.readFileSync(filePath, 'utf8');
      const relativePath = path.relative(process.cwd(), filePath);

      const fileAnalysis = {
        file: relativePath,
        vulnerabilities: [],
        riskScore: 0
      };

      // Scan for security vulnerabilities
      this.checkSecurityPatterns(content, fileAnalysis);

      this.results.vulnerabilities.push(...fileAnalysis.vulnerabilities);
    } catch (error) {
      console.warn(chalk.yellow(`âš ï¸  Could not scan ${filePath}: ${error.message}`));
    }
  }

  checkSecurityPatterns (content, fileAnalysis) {
    const lines = content.split('\n');

    for (const [severity, patterns] of Object.entries(this.securityPatterns)) {
      for (const { pattern, message, cwe, recommendation } of patterns) {
        const matches = content.match(new RegExp(pattern, 'g'));
        if (matches) {
          for (const match of matches) {
            const index = content.indexOf(match);
            const lineNumber = content.substring(0, index).split('\n').length;

            fileAnalysis.vulnerabilities.push({
              severity,
              message,
              cwe,
              recommendation,
              line: lineNumber,
              code: match.trim(),
              file: fileAnalysis.file
            });
          }
        }
      }
    }

    // Calculate file risk score
    fileAnalysis.riskScore = this.calculateFileRiskScore(fileAnalysis.vulnerabilities);
  }

  calculateFileRiskScore (vulnerabilities) {
    let score = 0;
    for (const vuln of vulnerabilities) {
      switch (vuln.severity) {
      case 'critical':
        score += 25;
        break;
      case 'high':
        score += 15;
        break;
      case 'medium':
        score += 8;
        break;
      case 'low':
        score += 3;
        break;
      }
    }
    return score;
  }

  calculateScore () {
    const maxScore = 100;
    const totalRiskScore = this.results.vulnerabilities.reduce((sum, vuln) => {
      switch (vuln.severity) {
      case 'critical':
        return sum + 25;
      case 'high':
        return sum + 15;
      case 'medium':
        return sum + 8;
      case 'low':
        return sum + 3;
      default:
        return sum;
      }
    }, 0);

    this.results.score = Math.max(0, maxScore - totalRiskScore);
  }

  generateReport () {
    const report = {
      timestamp: new Date().toISOString(),
      score: this.results.score,
      totalVulnerabilities: this.results.vulnerabilities.length,
      vulnerabilitiesBySeverity: this.groupVulnerabilitiesBySeverity(),
      vulnerabilitiesByCWE: this.groupVulnerabilitiesByCWE(),
      recommendations: this.generateRecommendations(),
      files: this.getAffectedFiles()
    };

    // Save detailed report
    fs.writeFileSync('security-scan-results.json', JSON.stringify(report, null, 2));

    // Generate SARIF format for GitHub
    this.generateSARIFReport(report);
  }

  groupVulnerabilitiesBySeverity () {
    const grouped = { critical: [], high: [], medium: [], low: [] };

    for (const vuln of this.results.vulnerabilities) {
      grouped[vuln.severity].push(vuln);
    }

    return grouped;
  }

  groupVulnerabilitiesByCWE () {
    const grouped = {};

    for (const vuln of this.results.vulnerabilities) {
      if (!grouped[vuln.cwe]) {
        grouped[vuln.cwe] = [];
      }
      grouped[vuln.cwe].push(vuln);
    }

    return grouped;
  }

  getAffectedFiles () {
    const fileMap = {};

    for (const vuln of this.results.vulnerabilities) {
      if (!fileMap[vuln.file]) {
        fileMap[vuln.file] = [];
      }
      fileMap[vuln.file].push(vuln);
    }

    return Object.keys(fileMap).map(file => ({
      file,
      vulnerabilities: fileMap[file].length,
      riskScore: this.calculateFileRiskScore(fileMap[file])
    }));
  }

  generateRecommendations () {
    const recommendations = [];
    const criticalCount = this.results.vulnerabilities.filter(v => v.severity === 'critical').length;
    const highCount = this.results.vulnerabilities.filter(v => v.severity === 'high').length;

    if (criticalCount > 0) {
      recommendations.push({
        priority: 'critical',
        message: `ðŸš¨ ${criticalCount} critical security vulnerabilities found - immediate action required`
      });
    }

    if (highCount > 0) {
      recommendations.push({
        priority: 'high',
        message: `âš ï¸ ${highCount} high-severity security vulnerabilities found - address urgently`
      });
    }

    // Add specific recommendations based on vulnerability types
    const cweGroups = this.groupVulnerabilitiesByCWE();
    if (cweGroups['CWE-79']) {
      recommendations.push({
        priority: 'high',
        message: 'ðŸ›¡ï¸ XSS vulnerabilities detected - implement input sanitization and output encoding'
      });
    }

    if (cweGroups['CWE-94']) {
      recommendations.push({
        priority: 'critical',
        message: 'ðŸ’¥ Code injection vulnerabilities detected - avoid dynamic code execution'
      });
    }

    if (cweGroups['CWE-338']) {
      recommendations.push({
        priority: 'medium',
        message: 'ðŸŽ² Weak randomness detected - use cryptographically secure random number generators'
      });
    }

    return recommendations;
  }

  generateSARIFReport (report) {
    const sarif = {
      $schema: 'https://json.schemastore.org/sarif-2.1.0',
      version: '2.1.0',
      runs: [
        {
          tool: {
            driver: {
              name: 'AI Security Scanner',
              version: '1.0.0',
              informationUri: 'https://github.com/ibetterai/cline-sdlc'
            }
          },
          results: this.results.vulnerabilities.map(vuln => ({
            level: this.getSeverityLevel(vuln.severity),
            message: {
              text: vuln.message
            },
            locations: [
              {
                physicalLocation: {
                  artifactLocation: {
                    uri: vuln.file
                  },
                  region: {
                    startLine: vuln.line,
                    startColumn: 1,
                    endLine: vuln.line,
                    endColumn: 100
                  }
                }
              }
            ],
            properties: {
              cwe: vuln.cwe,
              recommendation: vuln.recommendation,
              code: vuln.code
            }
          }))
        }
      ]
    };

    fs.writeFileSync('security-scan-results.sarif', JSON.stringify(sarif, null, 2));
  }

  getSeverityLevel (severity) {
    switch (severity) {
    case 'critical':
      return 'error';
    case 'high':
      return 'error';
    case 'medium':
      return 'warning';
    case 'low':
      return 'note';
    default:
      return 'note';
    }
  }
}

// Run security scanner
if (require.main === module) {
  const scanner = new SecurityVulnerabilityScanner();
  const targetPath = process.argv[2] || '.';
  scanner.scan(targetPath).catch(console.error);
}

module.exports = SecurityVulnerabilityScanner;
